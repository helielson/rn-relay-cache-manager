{"version":3,"sources":["../../src/CacheWriter.js"],"names":["CacheRecordStore","DEFAULT_CACHE_KEY","CacheWriter","constructor","options","cacheKey","storage","localStorage","writeInterval","cachedData","cache","fromJSON","clearStorage","removeItem","throttle","fn","context","writeTimeout","setTimeout","apply","writeField","dataId","field","value","typeName","record","records","__dataID__","__typename","serialized","JSON","stringify","key","indexOf","push","setItem","err","console","log","writeNode","writeRecord","readNode","writeRootCall","storageKey","identifyingArgValue","rootCallMap","readRootCall","callName","callValue","callback","setImmediate","bind"],"mappings":"AAAA;;;;;;;AAOA,OAAOA,gBAAP,MAA6B,oBAA7B;;;AAGA,MAAMC,oBAA4B,gBAAlC;;AAUA,eAAe,MAAMC,WAAN,CAAkB;;AAO/BC,cAAYC,UAA8B,EAA1C,EAA8C;AAC5C,SAAKC,QAAL,GAAgBD,QAAQC,QAAR,IAAoBJ,iBAApC;AACA,SAAKK,OAAL,GAAeF,QAAQE,OAAR,IAAmBC,YAAlC;AACA,SAAKC,aAAL,GAAqBJ,QAAQI,aAAR,IAAyB,GAA9C;;AAEA,QAAIJ,QAAQK,UAAZ,EAAwB;AACtB,WAAKC,KAAL,GAAaV,iBAAiBW,QAAjB,CAA0BP,QAAQK,UAAlC,CAAb;AACD,KAFD,MAEO;AACL,WAAKC,KAAL,GAAa,IAAIV,gBAAJ,EAAb;AACD;AACF;;AAEDY,iBAAe;AACb,SAAKN,OAAL,CAAaO,UAAb,CAAwB,KAAKR,QAA7B;AACA,SAAKK,KAAL,GAAa,IAAIV,gBAAJ,EAAb;AACD;;AAEDc,WAASC,EAAT,EAAuB;AACrB,UAAMC,UAAU,IAAhB;AACA,QAAI,CAAC,KAAKC,YAAV,EAAwB;AACtB,WAAKA,YAAL,GAAoBC,WAAW,MAAM;AACnCH,WAAGI,KAAH,CAASH,OAAT;AACA,aAAKC,YAAL,GAAoB,IAApB;AACD,OAHmB,EAGjB,KAAKT,aAHY,CAApB;AAID;AACF;;AAEDY,aACEC,MADF,EAEEC,KAFF,EAGEC,KAHF,EAIEC,QAJF,EAKE;AACA,QAAIC,SAAS,KAAKf,KAAL,CAAWgB,OAAX,CAAmBL,MAAnB,CAAb;AACA,QAAI,CAACI,MAAL,EAAa;AACXA,eAAS;AACPE,oBAAYN,MADL;AAEPO,oBAAYJ;AAFL,OAAT;AAID;AACDC,WAAOH,KAAP,IAAgBC,KAAhB;AACA,SAAKb,KAAL,CAAWgB,OAAX,CAAmBL,MAAnB,IAA6BI,MAA7B;;AAEA,QAAI;AACF,UAAIf,QAAQ,EAAZ;AACA,YAAMmB,aAAaC,KAAKC,SAAL,CAAe,KAAKrB,KAApB,EAA2B,CAACsB,GAAD,EAAMT,KAAN,KAAgB;AAC5D,YAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,UAAU,IAA3C,EAAiD;AAC/C,cAAIb,SAASA,MAAMuB,OAAN,CAAcV,KAAd,MAAyB,CAAC,CAAvC,EAA0C;AACxC;AACA;AACD;AACD;AACAb,mBAASA,MAAMwB,IAAN,CAAWX,KAAX,CAAT;AACD;AACD,eAAOA,KAAP;AACD,OAVkB,CAAnB;AAWAb,cAAQ,IAAR;AACA,WAAKI,QAAL,CAAc,MAAM,KAAKR,OAAL,CAAa6B,OAAb,CAAqB,KAAK9B,QAA1B,EAAoCwB,UAApC,CAApB;AACD,KAfD,CAeE,OAAOO,GAAP,EAAY;AACZ;AACAC,cAAQC,GAAR,CACE,gCADF,EAEE,KAAKjC,QAFP,EAGE,aAHF,EAIE,KAAKK,KAJP;AAMA2B,cAAQC,GAAR,CAAYF,GAAZ;AACD;AACF;;AAEDG,YAAUlB,MAAV,EAA0BI,MAA1B,EAA+C;AAC7C,SAAKf,KAAL,CAAW8B,WAAX,CAAuBnB,MAAvB,EAA+BI,MAA/B;AACD;;AAEDgB,WAASpB,MAAT,EAAyB;AACvB,UAAMI,SAAS,KAAKf,KAAL,CAAW+B,QAAX,CAAoBpB,MAApB,CAAf;AACA,WAAOI,MAAP;AACD;;AAEDiB,gBACEC,UADF,EAEEC,mBAFF,EAGEvB,MAHF,EAIE;AACA,SAAKX,KAAL,CAAWmC,WAAX,CAAuBF,UAAvB,IAAqCtB,MAArC;AACD;;AAEDyB,eACEC,QADF,EAEEC,SAFF,EAGEC,QAHF,EAIE;AACA,UAAM5B,SAAS,KAAKX,KAAL,CAAWmC,WAAX,CAAuBE,QAAvB,CAAf;AACAG,iBAAaD,SAASE,IAAT,CAAc,IAAd,EAAoB,IAApB,EAA0B9B,MAA1B,CAAb;AACD;AArG8B","file":"CacheWriter.js","sourcesContent":["/**\n *  Implements the CacheWriter interface specified by\n *  RelayTypes, uses an instance of CacheRecordStore\n *  to manage the CacheRecord instances\n *  @flow\n */\n\nimport CacheRecordStore from './CacheRecordStore';\nimport type { CacheRecord } from './CacheRecordStore';\n\nconst DEFAULT_CACHE_KEY: string = '__RelayCache__';\n\nexport type CacheWriterOptions = {\n  cacheKey?: string,\n  storage?: any,\n  cachedData?: Object,\n  writeInterval?: number,\n}\n\n\nexport default class CacheWriter {\n  cache: CacheRecordStore;\n  cacheKey: string;\n  storage: any;\n  writeInterval: number;\n  writeTimeout: setTimeout;\n\n  constructor(options: CacheWriterOptions = {}) {\n    this.cacheKey = options.cacheKey || DEFAULT_CACHE_KEY;\n    this.storage = options.storage || localStorage;\n    this.writeInterval = options.writeInterval || 500;\n\n    if (options.cachedData) {\n      this.cache = CacheRecordStore.fromJSON(options.cachedData);\n    } else {\n      this.cache = new CacheRecordStore();\n    }\n  }\n\n  clearStorage() {\n    this.storage.removeItem(this.cacheKey);\n    this.cache = new CacheRecordStore();\n  }\n\n  throttle(fn: Function) {\n    const context = this;\n    if (!this.writeTimeout) {\n      this.writeTimeout = setTimeout(() => {\n        fn.apply(context);\n        this.writeTimeout = null;\n      }, this.writeInterval);\n    }\n  }\n\n  writeField(\n    dataId: string,\n    field: string,\n    value: ?mixed,\n    typeName: ?string\n  ) {\n    let record = this.cache.records[dataId];\n    if (!record) {\n      record = {\n        __dataID__: dataId,\n        __typename: typeName,\n      }\n    }\n    record[field] = value;\n    this.cache.records[dataId] = record;\n\n    try {\n      let cache = [];\n      const serialized = JSON.stringify(this.cache, (key, value) => {\n        if (typeof value === 'object' && value !== null) {\n          if (cache && cache.indexOf(value) !== -1) {\n            // Circular reference found, discard key\n            return;\n          }\n          // Store value in our collection\n          cache && cache.push(value);\n        }\n        return value;\n      });\n      cache = null;\n      this.throttle(() => this.storage.setItem(this.cacheKey, serialized));\n    } catch (err) {\n      /* noop */\n      console.log(\n        'I can\\'t write cache with key ',\n        this.cacheKey,\n        ' and value ',\n        this.cache\n      );\n      console.log(err);\n    }\n  }\n\n  writeNode(dataId: string, record: CacheRecord) {\n    this.cache.writeRecord(dataId, record);\n  }\n\n  readNode(dataId: string) {\n    const record = this.cache.readNode(dataId)\n    return record;\n  }\n\n  writeRootCall(\n    storageKey: string,\n    identifyingArgValue: string,\n    dataId: string\n  ) {\n    this.cache.rootCallMap[storageKey] = dataId;\n  }\n\n  readRootCall(\n    callName: string,\n    callValue: string,\n    callback: (error: any, value: any) => void\n  ) {\n    const dataId = this.cache.rootCallMap[callName];\n    setImmediate(callback.bind(null, null, dataId));\n  }\n}\n"]}